---
title: "test for latent variables"
date: '`r format(Sys.time(), "%B %d, %Y")`'
---


```{r global_options, include=FALSE}
knitr::opts_chunk$set(echo=TRUE,
                      warning=FALSE,
                      message=FALSE)
```

```{r caching, include=FALSE}
library(methods)
library(knitr)
library(kableExtra)
```

```{r} 
library(tidyverse)
library(rstan)
library(stringr)
library(loo)
rstan_options(auto_write = TRUE)
# options(mc.cores = parallel::detectCores())
options(mc.cores = 3)

set.seed(5)

n_chains <- 3

dat <- read_csv("./data/GL_data.csv") %>%
    mutate(DE = ifelse(is.na(DE), "U", DE)) %>%
    as.data.frame

  list_dat <- list(n_sample = nrow(dat),
                   obs = cbind(log(dat[ , "Aarea"] + dat[ , "Rarea"]),
                               log(dat[ , "LL"]),
                               log(dat[ , "Rarea"])),
                   LMA = dat[ , "LMA"],
                   A = dat[ , "Aarea"],
                   R = dat[ , "Rarea"],
                   q_lim = 1,
                   leaf = 1,
                   dry = 1,
                   DE = as.numeric(as.factor(dat$DE)))

  list_dat$obs2 <- list_dat$obs


model <- "
  data{
    int<lower=0> n_sample;
    vector<lower=0>[n_sample] LMA;
    row_vector[3] obs[n_sample];
  }
  parameters{
    real log_alpha;
    real alpha2;
    real log_beta;
    real beta2;
    real rp;
    real rs;
    real log_r;
    vector<lower=0>[3] L_sigma;
    cholesky_factor_corr[3] L_Omega;
    vector<lower=0, upper=1>[n_sample] p;
  }
  transformed parameters{
    row_vector[3] mu[n_sample];
    for (i in 1:n_sample){
      mu[i,1] = log_alpha + alpha2 * (log(LMA[i]) + log(p[i]))
            - 0.5 * square(L_sigma[1]);
      mu[i,2] = log_beta + beta2 * (log(LMA[i]) + log(1-p[i]))
             - 0.5 * square(L_sigma[2]);
      mu[i,3] = log_r +  rp * (log(LMA[i]) + log(p[i]))
              + rs * (log(LMA[i]) + log(1-p[i]))
               - 0.5 * square(L_sigma[3]);
    }
  }
  model{
    obs ~ multi_normal_cholesky(mu, diag_pre_multiply(L_sigma, L_Omega));
    p ~ uniform(0, 1);
    log_alpha ~ normal(0, 1.0e+4);
    log_beta ~ normal(0, 1.0e+4);
    alpha2 ~ normal(0, 1.0e+4);
    beta2 ~ normal(0, 1.0e+4);
    rp ~ normal(0, 1.0e+4);
    rs ~ normal(0, 1.0e+4);
    log_r ~ normal(0, 1.0e+4);
    L_Omega ~ lkj_corr_cholesky(1); //uniform of L_Omega * L_Omega'
    L_sigma ~ uniform(0, 1.0e+4);
  }
  generated quantities {
    vector[n_sample] log_lik;
    real<lower=-1, upper=1> rho12;
    real<lower=-1, upper=1> rho23;
    real<lower=-1, upper=1> rho13;
    cov_matrix[3] Sigma;
    Sigma = diag_pre_multiply(L_sigma, L_Omega)
       * diag_post_multiply(L_Omega', L_sigma);
    rho12 = Sigma[1, 2] * inv(L_sigma[1] * L_sigma[2]);
    rho23 = Sigma[2, 3] * inv(L_sigma[2] * L_sigma[3]);
    rho13 = Sigma[1, 3] * inv(L_sigma[1] * L_sigma[3]);
    for (i in 1:n_sample)
     log_lik[i] = multi_normal_cholesky_lpdf(obs[i] | mu[i], diag_pre_multiply(L_sigma, L_Omega));
   }
"

model2 <- "
  data{
    int<lower=0> n_sample;
    vector<lower=0>[n_sample] LMA;
    row_vector[3] obs[n_sample];
  }
  parameters{
    real log_alpha;
    real alpha2;
    real log_beta;
    real beta2;
    real rp;
    real rs;
    real log_r;
    vector<lower=0>[3] L_sigma;
    cholesky_factor_corr[3] L_Omega;
    vector[n_sample] z;
  }
  transformed parameters{
    row_vector[3] mu[n_sample];
    vector<lower=0, upper=1>[n_sample] p;
    for (i in 1:n_sample){
      p[i] = inv_logit(z[i]);
      mu[i,1] = log_alpha + alpha2 * (log(LMA[i]) + log(p[i]))
            - 0.5 * square(L_sigma[1]);
      mu[i,2] = log_beta + beta2 * (log(LMA[i]) + log(1-p[i]))
             - 0.5 * square(L_sigma[2]);
      mu[i,3] = log_r +  rp * (log(LMA[i]) + log(p[i]))
              + rs * (log(LMA[i]) + log(1-p[i]))
               - 0.5 * square(L_sigma[3]);
    }
  }
  model{
    obs ~ multi_normal_cholesky(mu, diag_pre_multiply(L_sigma, L_Omega));
    z ~ normal(0, 5);
    log_alpha ~ normal(0, 1.0e+4);
    log_beta ~ normal(0, 1.0e+4);
    alpha2 ~ normal(0, 1.0e+4);
    beta2 ~ normal(0, 1.0e+4);
    rp ~ normal(0, 1.0e+4);
    rs ~ normal(0, 1.0e+4);
    log_r ~ normal(0, 1.0e+4);
    L_Omega ~ lkj_corr_cholesky(1); //uniform of L_Omega * L_Omega'
    L_sigma ~ uniform(0, 1.0e+4);
  }
  generated quantities {
    vector[n_sample] log_lik;
    real<lower=-1, upper=1> rho12;
    real<lower=-1, upper=1> rho23;
    real<lower=-1, upper=1> rho13;
    cov_matrix[3] Sigma;
    Sigma = diag_pre_multiply(L_sigma, L_Omega)
       * diag_post_multiply(L_Omega', L_sigma);
    rho12 = Sigma[1, 2] * inv(L_sigma[1] * L_sigma[2]);
    rho23 = Sigma[2, 3] * inv(L_sigma[2] * L_sigma[3]);
    rho13 = Sigma[1, 3] * inv(L_sigma[1] * L_sigma[3]);
    for (i in 1:n_sample)
     log_lik[i] = multi_normal_cholesky_lpdf(obs[i] | mu[i], diag_pre_multiply(L_sigma, L_Omega));
   }
"

n_iter <- 20000
n_warm <- 10000
n_thin <- 20

system.time(fit <- stan(model_code = model,
            data = list_dat,
            iter = 1,
            warmup = 0,
            thin = 1,
            chains = 1))


system.time(fit2 <- stan(model_code = model2,
            data = list_dat,
            iter = 1,
            warmup = 0,
            thin = 1,
            chains = 1))

system.time(res <- stan(fit = fit,
           data = list_dat,
           iter = n_iter,
           warmup = n_warm,
           thin = n_thin,
           chains = n_chains,
           control = list(adapt_delta = 0.95, max_treedepth = 10)))


system.time(res2 <- stan(fit = fit2,
           data = list_dat,
           iter = n_iter,
           warmup = n_warm,
           thin = n_thin,
           chains = n_chains,
           control = list(adapt_delta = 0.95, max_treedepth = 10)))


GL_summary <- data.frame(summary(res)$summary)
GL_summary2 <- data.frame(summary(res2)$summary)

write.csv(GL_summary,"model.csv")
write.csv(GL_summary2,"model2.csv")

GL_summary %>% head(20) %>% print
GL_summary2 %>% head(20) %>% print

save.image("model.rda")
save.image("model2.rda")

```


```{r}
load("model.rda")
load("model2.rda")

P_vec <- paste("p[", 1:nrow(dat), "]" ,sep = "")

GL <- dat %>%
  mutate(DE = ifelse(GL$DE == "", "U", as.character(DE))) %>%
  mutate(p1 = GL_summary[P_vec, "X50."]) %>%
  mutate(p2 = GL_summary2[P_vec, "X50."]) %>%
  mutate(LMAp1 =  p1 * LMA) %>%
  mutate(LMAs1 = LMA - LMAp1) %>% 
  mutate(LMAp2 = p2 * LMA) %>%
  mutate(LMAs2 = LMA - LMAp2) %>%
  mutate(AR = Aarea + Rarea)


# p1 vs p2
ggplot(GL, aes(x = p1, y = p2)) +
  geom_point() +
  geom_abline(slope=1, intercept=0, lty = 2)


ggplot(GL, aes(x = LMAp1, y = AR)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() 


ggplot(GL, aes(x = LMAp2, y = AR)) +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() 
```
