
R version 3.4.2 (2017-09-28) -- "Short Summer"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin17.0.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(tidyverse)
> library(rstan)
> library(loo)
> rstan_options(auto_write = TRUE)
> # options(mc.cores = parallel::detectCores())
> options(mc.cores = 3)
> 
> set.seed(5)
> 
> n_chains <- 3
> 
> argv <- commandArgs(trailingOnly = TRUE)
> n_model <- noquote(argv[1])
> data_name <- argv[2]
> n_iter <- as.numeric(argv[3])
> n_warm <- as.numeric(argv[4])
> n_thin <- as.numeric(argv[5])
> obs <- argv[6]
> 
> #n_model <- noquote("potLL")
> #data_name <- "GL1"
> #n_iter <- 2000
> #n_warm <- 1000
> #n_thin <- 20
> #obs <- "obs"
> 
> print(paste("Model:", n_model))
[1] "Model: pot_com"
> print(paste("Data:", data_name))
[1] "Data: GL"
> print(paste("n_iter =", n_iter))
[1] "n_iter = 2000"
> print(paste("n_warm =", n_warm))
[1] "n_warm = 1000"
> print(paste("n_thin =", n_thin))
[1] "n_thin = 2"
> print(paste("n_chains =", n_chains))
[1] "n_chains = 3"
> 
> if (data_name == "GL") {
+   dat <- read_csv("./data/GL_data.csv") %>%
+     mutate(DE = ifelse(is.na(DE), "U", DE)) %>%
+     as.data.frame
+ 
+   list_dat <- list(n_sample = nrow(dat),
+                    obs = cbind(log(dat[ , "Aarea"] + dat[ , "Rarea"]),
+                                log(dat[ , "LL"]),
+                                log(dat[ , "Rarea"])),
+                    LMA = dat[ , "LMA"],
+                    A = dat[ , "Aarea"],
+                    R = dat[ , "Rarea"],
+                    q_lim = 1,
+                    leaf = 1,
+                    dry = 1,
+                    DE = as.numeric(as.factor(dat$DE)))
+ 
+ } else if (data_name == "PA") {
+ 
+   dat <- read_csv("./data/PA_data.csv") %>%
+     filter(!is.na(LMA)) %>%
+     filter(!is.na(Aarea)) %>%
+     filter(!is.na(Rarea)) %>%
+     filter(!is.na(LL)) %>%
+     as.data.frame
+ 
+   q_lim <- dat %>%
+     filter(strata == "UNDER") %>%
+     mutate(q = Rarea/Aarea) %>%
+     summarize(max(q)) %>%
+     as.numeric()
+ 
+   list_dat <- list(n_sample = nrow(dat),
+                    obs = cbind(log(dat[ , "Aarea"] + dat[ , "Rarea"]),
+                                log(dat[ , "LL"]),
+                                log(dat[ , "Rarea"])),
+                    LMA = dat[ , "LMA"],
+                    A = dat[ , "Aarea"],
+                    R = dat[ , "Rarea"],
+                    DE = 1,
+                    q_lim = q_lim,
+                    leaf = as.numeric(as.factor(dat$strata)),
+                    dry = ifelse(dat$site == "PNM", 1 , 0))
+ }
> 
> list_dat_n <- list()
> for (i in 1:10){
+     temp <- data.frame(dat[,1:3],
+              LMA = sample(dat$LMA),
+              LL = sample(dat$LL),
+              Aarea = sample(dat$Aarea),
+              Rarea = sample(dat$Rarea)
+              ) 
+     while (min(temp$Aarea - temp$Rarea) < 0){
+     temp <- data.frame(dat[,1:3],
+              LMA = sample(dat$LMA),
+              LL = sample(dat$LL),
+              Aarea = sample(dat$Aarea),
+              Rarea = sample(dat$Rarea)
+              ) 
+     }
+ 
+   rand <- cbind(log(temp[ , "Aarea"] + temp[ , "Rarea"]),
+         log(temp[ , "LL"]),
+         log(temp[ , "Rarea"]))
+   temp$A_R <- temp$A - temp$R
+ 
+   list_dat_n[[i]] <- list(n_sample = list_dat$n_sample,
+             obs = rand,
+             A = temp$Aarea,
+             R = temp$Rarea,
+             q_lim = list_dat$q_lim,
+             leaf = list_dat$leaf,
+             dry = list_dat$dry,
+             DE = list_dat$DE,
+             LMA = list_dat$LMA)
+ } 
> 
> # setwd("~/Dropbox/LES/")
> 
> #potential LL
> pot <- "
+   data{
+     int<lower=0> n_sample;
+     vector<lower=0>[n_sample] LMA;
+     row_vector[3] obs[n_sample];
+   }
+   parameters{
+     real log_alpha;
+     real log_beta;
+     real rp;
+     real rs;
+     vector<lower=0>[3] L_sigma;
+     cholesky_factor_corr[3] L_Omega;
+     vector<lower=0.001, upper=0.999>[n_sample] p;
+   }
+   transformed parameters{
+     row_vector[3] mu[n_sample];
+     real<lower=0> mu3;
+     for (i in 1:n_sample){
+       mu[i,1] = log_alpha + log(LMA[i]) + log(p[i])
+              - 0.5 * square(L_sigma[1]);
+       mu[i,2] = log_beta + log(LMA[i]) + log(1-p[i])
+              - 0.5 * square(L_sigma[2]);
+       mu3 = rp * LMA[i] * p[i] + rs * LMA[i] * (1 - p[i]);
+       mu[i,3]  = log(mu3) - 0.5 * square(L_sigma[3]);
+     }
+   }
+   model{
+     obs ~ multi_normal_cholesky(mu, diag_pre_multiply(L_sigma, L_Omega));
+     p ~ uniform(0.001, 0.999);
+     log_alpha ~ normal(0, 1.0e+4);
+     log_beta ~ normal(0, 1.0e+4);
+     rp ~ normal(0, 1.0e+4);
+     rs ~ normal(0, 1.0e+4);
+     L_Omega ~ lkj_corr_cholesky(1); //uniform of L_Omega * L_Omega'
+     L_sigma ~ uniform(0, 1.0e+4);
+   }
+  generated quantities {
+     vector[n_sample] log_lik;
+     real<lower=-1, upper=1> rho12;
+     real<lower=-1, upper=1> rho23;
+     real<lower=-1, upper=1> rho13;
+     cov_matrix[3] Sigma;
+     Sigma = diag_pre_multiply(L_sigma, L_Omega)
+         * diag_post_multiply(L_Omega', L_sigma);
+     rho12 = Sigma[1, 2] * inv(L_sigma[1] * L_sigma[2]);
+     rho23 = Sigma[2, 3] * inv(L_sigma[2] * L_sigma[3]);
+     rho13 = Sigma[1, 3] * inv(L_sigma[1] * L_sigma[3]);
+     for (i in 1:n_sample)
+      log_lik[i] = multi_normal_cholesky_lpdf(obs[i] | mu[i], diag_pre_multiply(L_sigma, L_Omega));
+    }
+ "
> potPL <- "
+   data{
+     int<lower=0> n_sample;
+     vector<lower=0>[n_sample] LMA;
+     row_vector[3] obs[n_sample];
+   }
+   parameters{
+     real log_alpha;
+     real alpha2;
+     real log_beta;
+     real beta2;
+     real rp;
+     real rs;
+     real log_r;
+     vector<lower=0>[3] L_sigma;
+     cholesky_factor_corr[3] L_Omega;
+     vector<lower=0, upper=1>[n_sample] p;
+   }
+   transformed parameters{
+     row_vector[3] mu[n_sample];
+ 
+     for (i in 1:n_sample){
+       mu[i,1] = log_alpha + alpha2 * (log(LMA[i]) + log(p[i]))
+              - 0.5 * square(L_sigma[1]);
+       mu[i,2] = log_beta + beta2 * (log(LMA[i]) + log(1-p[i]))
+              - 0.5 * square(L_sigma[2]);
+       mu[i,3]  = log_r +  rp * (log(LMA[i]) + log(p[i]))
+               + rs * (log(LMA[i]) + log(1-p[i]))
+                - 0.5 * square(L_sigma[3]);
+     }
+   }
+   model{
+     obs ~ multi_normal_cholesky(mu, diag_pre_multiply(L_sigma, L_Omega));
+     p ~ uniform(0, 1);
+     log_alpha ~ normal(0, 1.0e+4);
+     log_beta ~ normal(0, 1.0e+4);
+     alpha2 ~ normal(0, 1.0e+4);
+     beta2 ~ normal(0, 1.0e+4);
+     rp ~ normal(0, 1.0e+4);
+     rs ~ normal(0, 1.0e+4);
+     log_r ~ normal(0, 1.0e+4);
+     L_Omega ~ lkj_corr_cholesky(1); //uniform of L_Omega * L_Omega'
+     L_sigma ~ uniform(0, 1.0e+4);
+   }
+   generated quantities {
+     vector[n_sample] log_lik;
+     real<lower=-1, upper=1> rho12;
+     real<lower=-1, upper=1> rho23;
+     real<lower=-1, upper=1> rho13;
+     cov_matrix[3] Sigma;
+     Sigma = diag_pre_multiply(L_sigma, L_Omega)
+        * diag_post_multiply(L_Omega', L_sigma);
+     rho12 = Sigma[1, 2] * inv(L_sigma[1] * L_sigma[2]);
+     rho23 = Sigma[2, 3] * inv(L_sigma[2] * L_sigma[3]);
+     rho13 = Sigma[1, 3] * inv(L_sigma[1] * L_sigma[3]);
+     for (i in 1:n_sample)
+      log_lik[i] = multi_normal_cholesky_lpdf(obs[i] | mu[i], diag_pre_multiply(L_sigma, L_Omega));
+    }
+ "
> 
> #using z pot
> pot_diff <- "
+   data{
+     int<lower=0> n_sample;
+     vector<lower=0>[n_sample] LMA;
+     vector<lower=0>[n_sample] A;
+     vector<lower=0>[n_sample] R;
+     row_vector[3] obs[n_sample];
+     int<lower=0> DE[n_sample];
+   }
+   parameters{
+     real log_alpha;
+     real alpha2;
+     real log_beta;
+     real beta2;
+     real log_r;
+     real rp;
+     real rs;
+     real mu_z;
+     real<lower=0> sigma_z;
+     real<lower=0> sigma_DE;
+     vector<lower=0>[3] L_sigma;
+     cholesky_factor_corr[3] L_Omega;
+     vector[3] u;
+     vector[n_sample] z;
+   }
+   transformed parameters{
+     row_vector[3] mu[n_sample];
+     vector<lower=0, upper=1.0>[n_sample] p;
+     p = 1 ./ (1 + exp(-z)); // vector
+     for (i in 1:n_sample){
+       mu[i,1] = log_alpha + alpha2 * (log(LMA[i]) + log(p[i]))
+              - 0.5 * square(L_sigma[1]);
+       mu[i,2] = log_beta + beta2 * (log(LMA[i]) + log(1-p[i]))
+              - 0.5 * square(L_sigma[2]);
+       mu[i,3]  = log_r +  rp * (log(LMA[i]) + log(p[i]))
+               + rs * (log(LMA[i]) + log(1-p[i]))
+                - 0.5 * square(L_sigma[3]);
+     }
+   }
+   model{
+     obs ~ multi_normal_cholesky(mu, diag_pre_multiply(L_sigma, L_Omega)); // vector
+     for (i in 1:n_sample) z[i] ~ normal(mu_z + u[DE[i]], sigma_z);
+     u ~ normal(0, sigma_DE); // vec
+     log_alpha ~ normal(0, 1.0e+4);
+     log_beta ~ normal(0, 1.0e+4);
+     alpha2 ~ normal(0, 1.0e+4);
+     beta2 ~ normal(0, 1.0e+4);
+     rp ~ normal(0, 1.0e+4);
+     rs ~ normal(0, 1.0e+4);
+     log_r ~ normal(0, 1.0e+4);
+     mu_z ~ normal(0, 1.0e+4); 
+     sigma_z ~ cauchy(0, 5);
+     sigma_DE ~ cauchy(0, 5);
+     L_Omega ~ lkj_corr_cholesky(1); //uniform of L_Omega * L_Omega'
+     L_sigma ~ cauchy(0, 5);
+   }
+   generated quantities {
+     vector[n_sample] log_lik;
+     real<lower=-1, upper=1> rho12;
+     real<lower=-1, upper=1> rho23;
+     real<lower=-1, upper=1> rho13;
+     cov_matrix[3] Sigma;
+     Sigma = diag_pre_multiply(L_sigma, L_Omega)
+        * diag_post_multiply(L_Omega', L_sigma);
+     rho12 = Sigma[1, 2] * inv(L_sigma[1] * L_sigma[2]);
+     rho23 = Sigma[2, 3] * inv(L_sigma[2] * L_sigma[3]);
+     rho13 = Sigma[1, 3] * inv(L_sigma[1] * L_sigma[3]);
+     for (i in 1:n_sample)
+      log_lik[i] = multi_normal_cholesky_lpdf(obs[i] | mu[i], diag_pre_multiply(L_sigma, L_Omega));
+    }
+ "
> 
> #using z pot
> pot_com <- "
+   data{
+     int<lower=0> n_sample;
+     vector<lower=0>[n_sample] LMA;
+     vector<lower=0>[n_sample] A;
+     vector<lower=0>[n_sample] R;
+     row_vector[3] obs[n_sample];
+   }
+   parameters{
+     real log_alpha;
+     real alpha2;
+     real log_beta;
+     real beta2;
+     real log_r;
+     real rp;
+     real rs;
+     real mu_z;
+     real<lower=0> sigma_z;
+     vector<lower=0>[3] L_sigma;
+     cholesky_factor_corr[3] L_Omega;
+     vector[n_sample] z;
+   }
+   transformed parameters{
+     row_vector[3] mu[n_sample];
+     vector<lower=0, upper=1.0>[n_sample] p;
+     p = 1 ./ (1 + exp(-z)); // vector
+     for (i in 1:n_sample){
+       mu[i,1] = log_alpha + alpha2 * (log(LMA[i]) + log(p[i]))
+              - 0.5 * square(L_sigma[1]);
+       mu[i,2] = log_beta + beta2 * (log(LMA[i]) + log(1-p[i]))
+              - 0.5 * square(L_sigma[2]);
+       mu[i,3]  = log_r +  rp * (log(LMA[i]) + log(p[i]))
+               + rs * (log(LMA[i]) + log(1-p[i]))
+                - 0.5 * square(L_sigma[3]);
+     }
+   }
+   model{
+     obs ~ multi_normal_cholesky(mu, diag_pre_multiply(L_sigma, L_Omega)); // vector
+     z ~ normal(mu_z, sigma_z);
+     log_alpha ~ normal(0, 10);
+     log_beta ~ normal(0, 10);
+     alpha2 ~ normal(0, 10);
+     beta2 ~ normal(0, 10);
+     rp ~ normal(0, 10);
+     rs ~ normal(0, 10);
+     mu_z ~ normal(0, 10); 
+     sigma_z ~ cauchy(0, 5);
+     L_Omega ~ lkj_corr_cholesky(1); //uniform of L_Omega * L_Omega'
+     L_sigma ~ cauchy(0, 5);
+   }
+   generated quantities {
+     vector[n_sample] log_lik;
+     real<lower=-1, upper=1> rho12;
+     real<lower=-1, upper=1> rho23;
+     real<lower=-1, upper=1> rho13;
+     cov_matrix[3] Sigma;
+     Sigma = diag_pre_multiply(L_sigma, L_Omega)
+        * diag_post_multiply(L_Omega', L_sigma);
+     rho12 = Sigma[1, 2] * inv(L_sigma[1] * L_sigma[2]);
+     rho23 = Sigma[2, 3] * inv(L_sigma[2] * L_sigma[3]);
+     rho13 = Sigma[1, 3] * inv(L_sigma[1] * L_sigma[3]);
+     for (i in 1:n_sample)
+      log_lik[i] = multi_normal_cholesky_lpdf(obs[i] | mu[i], diag_pre_multiply(L_sigma, L_Omega));
+    }
+ "
> 
> # PA model
> optPL <- "
+   data{
+     int<lower=0> n_sample;
+     vector<lower=0>[n_sample] LMA;
+     vector<lower=0>[n_sample] A;
+     vector<lower=0>[n_sample] R;
+     row_vector[3] obs[n_sample];
+     real<lower=0> q_lim;
+     int<lower=0> leaf[n_sample];
+     int<lower=0> dry[n_sample];
+   }
+   parameters{
+     real log_alpha;
+     real log_beta;
+     real rp;
+     real rs;
+     real alpha2;
+     real log_r;
+     real<lower=q_lim, upper=0.999> q;
+     vector<lower=0>[3] L_sigma;
+     cholesky_factor_corr[3] L_Omega;
+     vector<lower=0.001, upper=0.999>[n_sample] p;
+   }
+   transformed parameters{
+     row_vector[3] mu[n_sample];
+     for (i in 1:n_sample){
+ 			mu[i,1] = log_alpha + alpha2 * (log(LMA[i]) + log(p[i]))
+              - 0.5 * square(L_sigma[1]);
+     if (leaf[i]==1) // sun
+       mu[i,2] = log_beta 
+             + 0.5 * (log(LMA[i]) + log(1 - p[i]))
+             - 0.5 * log(A[i] - R[i])
+             - 0.5 * square(L_sigma[2]);
+     else
+       mu[i,2] = log_beta 
+             + 0.5 * (log(LMA[i]) + log(1 - p[i]))
+             - 0.5 * log(q * A[i] - R[i])
+             - 0.5 * square(L_sigma[2]);
+ 
+ 		mu[i,3]  = log_r + rp * (log(LMA[i]) + log(p[i]))
+ 						+ rs * (log(LMA[i]) + log(1-p[i]))
+ 						- 0.5 * square(L_sigma[3]);
+     }
+   }
+   model{
+     obs ~ multi_normal_cholesky(mu, diag_pre_multiply(L_sigma, L_Omega));
+     p ~ uniform(0.001, 0.999);
+     log_alpha ~ normal(0, 1.0e+4);
+     log_beta ~ normal(0, 1.0e+4);
+     rp ~ normal(0, 1.0e+4);
+     rs ~ normal(0, 1.0e+4);
+     alpha2 ~ normal(0, 1.0e+4);
+     log_r ~ normal(0, 1.0e+4);
+     q ~ uniform(q_lim, 0.999);
+     L_Omega ~ lkj_corr_cholesky(1);
+     L_sigma ~ uniform(0, 1.0e+4);
+   }
+   generated quantities {
+     vector[n_sample] log_lik;
+     real<lower=-1, upper=1> rho12;
+     real<lower=-1, upper=1> rho23;
+     real<lower=-1, upper=1> rho13;
+     cov_matrix[3] Sigma;
+     Sigma = diag_pre_multiply(L_sigma, L_Omega)
+        * diag_post_multiply(L_Omega', L_sigma);
+     rho12 = Sigma[1, 2] * inv(L_sigma[1] * L_sigma[2]);
+     rho23 = Sigma[2, 3] * inv(L_sigma[2] * L_sigma[3]);
+     rho13 = Sigma[1, 3] * inv(L_sigma[1] * L_sigma[3]);
+     for (i in 1:n_sample)
+       log_lik[i] = multi_normal_cholesky_lpdf(obs[i] | mu[i], diag_pre_multiply(L_sigma, L_Omega));
+    }
+ "
> 
> sitePL <- "
+   data{
+     int<lower=0> n_sample;
+     vector<lower=0>[n_sample] LMA;
+     vector<lower=0>[n_sample] A;
+     vector<lower=0>[n_sample] R;
+     row_vector[3] obs[n_sample];
+     real<lower=0> q_lim;
+     int<lower=0> leaf[n_sample];
+     int<lower=0> dry[n_sample];
+   }
+   parameters{
+     real log_alpha;
+     real log_beta;
+     real rp;
+     real rs;
+     real alpha2;
+     real log_r;
+     real log_site;
+     real<lower=q_lim, upper=0.999> q;
+     vector<lower=0>[3] L_sigma;
+     cholesky_factor_corr[3] L_Omega;
+     vector<lower=0.001, upper=0.999>[n_sample] p;
+   }
+   transformed parameters{
+     row_vector[3] mu[n_sample];
+     for (i in 1:n_sample){
+ 			mu[i,1] = log_alpha + alpha2 * (log(LMA[i]) + log(p[i]))
+              - 0.5 * square(L_sigma[1]);
+     if (leaf[i]==1) // sun
+       mu[i,2] = log_beta + log_site * dry[i] 
+             + 0.5 * (log(LMA[i]) + log(1 - p[i]))
+             - 0.5 * log(A[i] - R[i])
+             - 0.5 * square(L_sigma[2]);
+     else
+       mu[i,2] = log_beta + log_site * dry[i] 
+             + 0.5 * (log(LMA[i]) + log(1 - p[i]))
+             - 0.5 * log(q * A[i] - R[i])
+             - 0.5 * square(L_sigma[2]);
+ 
+ 		mu[i,3]  = log_r + rp * (log(LMA[i]) + log(p[i]))
+ 						+ rs * (log(LMA[i]) + log(1-p[i]))
+ 						- 0.5 * square(L_sigma[3]);
+     }
+   }
+   model{
+     obs ~ multi_normal_cholesky(mu, diag_pre_multiply(L_sigma, L_Omega));
+     p ~ uniform(0.001, 0.999);
+     log_alpha ~ normal(0, 1.0e+4);
+     log_beta ~ normal(0, 1.0e+4);
+     rp ~ normal(0, 1.0e+4);
+     rs ~ normal(0, 1.0e+4);
+     alpha2 ~ normal(0, 1.0e+4);
+     log_r ~ normal(0, 1.0e+4);
+     log_site ~ normal(0, 1.0e+4);
+     q ~ uniform(q_lim, 0.999);
+     L_Omega ~ lkj_corr_cholesky(1);
+     L_sigma ~ uniform(0, 1.0e+4);
+   }
+   generated quantities {
+     vector[n_sample] log_lik;
+     real<lower=-1, upper=1> rho12;
+     real<lower=-1, upper=1> rho23;
+     real<lower=-1, upper=1> rho13;
+     cov_matrix[3] Sigma;
+     Sigma = diag_pre_multiply(L_sigma, L_Omega)
+        * diag_post_multiply(L_Omega', L_sigma);
+     rho12 = Sigma[1, 2] * inv(L_sigma[1] * L_sigma[2]);
+     rho23 = Sigma[2, 3] * inv(L_sigma[2] * L_sigma[3]);
+     rho13 = Sigma[1, 3] * inv(L_sigma[1] * L_sigma[3]);
+     for (i in 1:n_sample)
+       log_lik[i] = multi_normal_cholesky_lpdf(obs[i] | mu[i], diag_pre_multiply(L_sigma, L_Omega));
+    }
+ "
> 
> if (obs == "obs") {
+ system.time(fit <- stan(model_code = get(n_model),
+             data = list_dat,
+             iter = 1,
+             warmup = 0,
+             thin = 1,
+             chains = 1))
+ 
+ system.time(res <- stan(fit = fit,
+            data = list_dat,
+            iter = n_iter,
+            warmup = n_warm,
+            thin = n_thin,
+            chains = n_chains,
+            control = list(adapt_delta = 0.95, max_treedepth = 10)))
+ 
+ save_name <- paste("./data/", data_name, "_", n_model, "_obs.rda", sep = "")
+ }
In file included from file1091e6166a696.cpp:8:
In file included from /usr/local/lib/R/3.4/site-library/StanHeaders/include/src/stan/model/model_header.hpp:4:
In file included from /usr/local/lib/R/3.4/site-library/StanHeaders/include/stan/math.hpp:4:
In file included from /usr/local/lib/R/3.4/site-library/StanHeaders/include/stan/math/rev/mat.hpp:4:
In file included from /usr/local/lib/R/3.4/site-library/StanHeaders/include/stan/math/rev/core.hpp:12:
In file included from /usr/local/lib/R/3.4/site-library/StanHeaders/include/stan/math/rev/core/gevv_vvv_vari.hpp:5:
In file included from /usr/local/lib/R/3.4/site-library/StanHeaders/include/stan/math/rev/core/var.hpp:7:
In file included from /usr/local/lib/R/3.4/site-library/BH/include/boost/math/tools/config.hpp:13:
In file included from /usr/local/lib/R/3.4/site-library/BH/include/boost/config.hpp:39:
/usr/local/lib/R/3.4/site-library/BH/include/boost/config/compiler/clang.hpp:200:11: warning: 'BOOST_NO_CXX11_RVALUE_REFERENCES' macro redefined [-Wmacro-redefined]
#  define BOOST_NO_CXX11_RVALUE_REFERENCES
          ^
<command line>:6:9: note: previous definition is here
#define BOOST_NO_CXX11_RVALUE_REFERENCES 1
        ^
1 warning generated.

SAMPLING FOR MODEL 'cefb3c1d8f45f5af42796559556889a1' NOW (CHAIN 1).

Gradient evaluation took 0.000917 seconds
1000 transitions using 10 leapfrog steps per transition would take 9.17 seconds.
Adjust your expectations accordingly!


WARNING: No variance estimation is
         performed for num_warmup < 20

Iteration: 1 / 1 [100%]  (Sampling)

 Elapsed Time: 2e-06 seconds (Warm-up)
               0.001592 seconds (Sampling)
               0.001594 seconds (Total)


SAMPLING FOR MODEL 'cefb3c1d8f45f5af42796559556889a1' NOW (CHAIN 1).

Gradient evaluation took 0.001011 seconds
1000 transitions using 10 leapfrog steps per transition would take 10.11 seconds.
Adjust your expectations accordingly!


Iteration:    1 / 2000 [  0%]  (Warmup)

SAMPLING FOR MODEL 'cefb3c1d8f45f5af42796559556889a1' NOW (CHAIN 2).

Gradient evaluation took 0.000958 seconds
1000 transitions using 10 leapfrog steps per transition would take 9.58 seconds.
Adjust your expectations accordingly!


Iteration:    1 / 2000 [  0%]  (Warmup)

SAMPLING FOR MODEL 'cefb3c1d8f45f5af42796559556889a1' NOW (CHAIN 3).

Gradient evaluation took 0.001026 seconds
1000 transitions using 10 leapfrog steps per transition would take 10.26 seconds.
Adjust your expectations accordingly!


Iteration:    1 / 2000 [  0%]  (Warmup)
Iteration:  200 / 2000 [ 10%]  (Warmup)
Iteration:  200 / 2000 [ 10%]  (Warmup)
Iteration:  200 / 2000 [ 10%]  (Warmup)
Iteration:  400 / 2000 [ 20%]  (Warmup)
Iteration:  400 / 2000 [ 20%]  (Warmup)
Iteration:  400 / 2000 [ 20%]  (Warmup)
Iteration:  600 / 2000 [ 30%]  (Warmup)
Iteration:  800 / 2000 [ 40%]  (Warmup)
Iteration:  600 / 2000 [ 30%]  (Warmup)
Iteration:  800 / 2000 [ 40%]  (Warmup)
Iteration: 1000 / 2000 [ 50%]  (Warmup)
Iteration: 1001 / 2000 [ 50%]  (Sampling)
Iteration:  600 / 2000 [ 30%]  (Warmup)
Iteration: 1000 / 2000 [ 50%]  (Warmup)
Iteration: 1001 / 2000 [ 50%]  (Sampling)
Iteration:  800 / 2000 [ 40%]  (Warmup)
Iteration: 1200 / 2000 [ 60%]  (Sampling)
Iteration: 1200 / 2000 [ 60%]  (Sampling)
Iteration: 1400 / 2000 [ 70%]  (Sampling)
Iteration: 1000 / 2000 [ 50%]  (Warmup)
Iteration: 1001 / 2000 [ 50%]  (Sampling)
Iteration: 1600 / 2000 [ 80%]  (Sampling)
Iteration: 1800 / 2000 [ 90%]  (Sampling)
Iteration: 1400 / 2000 [ 70%]  (Sampling)
Iteration: 2000 / 2000 [100%]  (Sampling)

 Elapsed Time: 160.36 seconds (Warm-up)
               236.225 seconds (Sampling)
               396.585 seconds (Total)

Iteration: 1200 / 2000 [ 60%]  (Sampling)
Iteration: 1600 / 2000 [ 80%]  (Sampling)
Iteration: 1400 / 2000 [ 70%]  (Sampling)
Iteration: 1800 / 2000 [ 90%]  (Sampling)
Iteration: 1600 / 2000 [ 80%]  (Sampling)
Iteration: 2000 / 2000 [100%]  (Sampling)

 Elapsed Time: 130.805 seconds (Warm-up)
               604.812 seconds (Sampling)
               735.617 seconds (Total)

Iteration: 1800 / 2000 [ 90%]  (Sampling)
Iteration: 2000 / 2000 [100%]  (Sampling)

 Elapsed Time: 286.029 seconds (Warm-up)
               592.415 seconds (Sampling)
               878.444 seconds (Total)

> 
> if (obs == "rand") {
+   res_list <- list()
+   summary_list <- list()
+   n_iter <- n_iter / 2
+   n_warm <- n_warm / 2
+   n_thin <- n_thin / 2
+   for (i in 1:10){
+ 
+     system.time(fit1 <- stan(model_code = get(n_model),
+                 data = list_dat_n[[i]],
+                 iter = 1,
+                 warmup = 0,
+                 thin = 1,
+                 chains = 1))
+ 
+     system.time(res_list[[i]] <- stan(fit = fit1,
+                data = list_dat_n[[i]],
+                iter = n_iter,
+                warmup = n_warm,
+                thin = n_thin,
+                chains = n_chains,
+                control = list(adapt_delta = 0.9,
+                   max_treedepth = 10)))
+ 
+     summary_list[[i]] <- data.frame(summary(res_list[[i]])$summary)
+   }
+   save_name <- paste("./data/", data_name, "_", n_model, "_rand.rda", sep = "")
+ }
> 
> save.image(save_name)
> 
